# -*- coding: utf-8 -*-
"""assignment_4_question1_and2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hNMxTTmJOl2j89hUOAJWxU1FqTlBBrHC
"""

import copy

class Puzzle:
    goal_state = [['T1', 'T2', 'T3'], ['T4', 'T5', 'T6'], ['T7', 'B', 'T8']]
    heuristic = None
    evaluation_function = None
    needs_hueristic = False

    def __init__(self, state):
        self.state = state
        if Puzzle.needs_hueristic:
            self.heuristic = self.get_heuristic()
            self.evaluation_function = self.heuristic

    def get_heuristic(self):
        # Calculate Manhattan Distance for 8-puzzle
        distance = 0
        for i in range(3):
            for j in range(3):
                if self.state[i][j] != Puzzle.goal_state[i][j] and self.state[i][j] != 'B':
                    goal_position = [(index // 3, index % 3) for index, value in enumerate(sum(Puzzle.goal_state, [])) if value == self.state[i][j]]
                    distance += abs(goal_position[0][0] - i) + abs(goal_position[0][1] - j)
        return distance

    def get_possible_moves(self):
        # Return a list of possible moves from current state
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 'B':
                    moves = []
                    if i > 0: moves.append('U')
                    if i < 2: moves.append('D')
                    if j > 0: moves.append('L')
                    if j < 2: moves.append('R')
                    return moves

    def generate_child(self, move):
        # Returns a Puzzle object after applying a move
        x, y = None, None
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 'B':
                    x, y = i, j
        new_state = copy.deepcopy(self.state)
        if move == 'U':
            new_state[x][y], new_state[x - 1][y] = new_state[x - 1][y], new_state[x][y]
        elif move == 'D':
            new_state[x][y], new_state[x + 1][y] = new_state[x + 1][y], new_state[x][y]
        elif move == 'L':
            new_state[x][y], new_state[x][y - 1] = new_state[x][y - 1], new_state[x][y]
        elif move == 'R':
            new_state[x][y], new_state[x][y + 1] = new_state[x][y + 1], new_state[x][y]
        return Puzzle(new_state)

def hill_climbing_search(puzzle):
    current_puzzle = puzzle
    while True:
        neighbors = []
        for move in current_puzzle.get_possible_moves():
            neighbors.append(current_puzzle.generate_child(move))

        if not neighbors:
            return None

        next_eval = float('inf')
        next_state = None
        for neighbor in neighbors:
            if neighbor.evaluation_function < next_eval:
                next_eval = neighbor.evaluation_function
                next_state = neighbor

        if next_eval >= current_puzzle.evaluation_function:
            # Return current state if no better neighbors are found
            return current_puzzle.state
        current_puzzle = next_state

if __name__ == '__main__':
    Puzzle.needs_hueristic = True
    initial_state = [
        ['T2', 'T8', 'T3'],
        ['T1', 'T6', 'T4'],
        ['T7', 'B', 'T5']
    ]
    print("Initial State:")
    for row in initial_state:
        print(row)

    puzzle = Puzzle(initial_state)
    result = hill_climbing_search(puzzle)
    print("\nResult:")
    for row in result:
        print(row)

import copy
import time

class Puzzle:
    goal_state = None
    heuristic = None
    evaluation_function = None
    needs_hueristic = False

    def __init__(self, state):
        self.state = state
        if Puzzle.needs_hueristic:
            self.heuristic = self.get_heuristic()
            self.evaluation_function = self.heuristic

    def get_heuristic(self):
        # Calculate Manhattan Distance for 8-puzzle
        distance = 0
        for i in range(3):
            for j in range(3):
                if self.state[i][j] != Puzzle.goal_state[i][j] and self.state[i][j] != 'B':
                    goal_position = [(index // 3, index % 3) for index, value in enumerate(sum(Puzzle.goal_state, [])) if value == self.state[i][j]]
                    distance += abs(goal_position[0][0] - i) + abs(goal_position[0][1] - j)
        return distance

    def get_possible_moves(self):
        # Return a list of possible moves from current state
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 'B':
                    moves = []
                    if i > 0: moves.append('U')
                    if i < 2: moves.append('D')
                    if j > 0: moves.append('L')
                    if j < 2: moves.append('R')
                    return moves

    def generate_child(self, move):
        # Returns a Puzzle object after applying a move
        x, y = None, None
        for i in range(3):
            for j in range(3):
                if self.state[i][j] == 'B':
                    x, y = i, j
        new_state = copy.deepcopy(self.state)
        if move == 'U':
            new_state[x][y], new_state[x - 1][y] = new_state[x - 1][y], new_state[x][y]
        elif move == 'D':
            new_state[x][y], new_state[x + 1][y] = new_state[x + 1][y], new_state[x][y]
        elif move == 'L':
            new_state[x][y], new_state[x][y - 1] = new_state[x][y - 1], new_state[x][y]
        elif move == 'R':
            new_state[x][y], new_state[x][y + 1] = new_state[x][y + 1], new_state[x][y]
        return Puzzle(new_state)

def hill_climbing_search(puzzle):
    current_puzzle = puzzle
    states_explored = 0
    optimal_path = [current_puzzle.state]

    while True:
        neighbors = []
        for move in current_puzzle.get_possible_moves():
            neighbors.append(current_puzzle.generate_child(move))

        states_explored += len(neighbors)

        if not neighbors:
            return None

        next_eval = float('inf')
        next_state = None
        for neighbor in neighbors:
            if neighbor.evaluation_function < next_eval:
                next_eval = neighbor.evaluation_function
                next_state = neighbor

        if next_eval >= current_puzzle.evaluation_function:
            # Return current state if no better neighbors are found
            return (current_puzzle.state, states_explored, optimal_path)
        current_puzzle = next_state
        optimal_path.append(current_puzzle.state)

def take_input():
    matrix = []
    for _ in range(3):
        row = input().split()
        matrix.append(row)
    return matrix

if __name__ == '__main__':
    print("Enter the initial state (e.g., T6 T7 T3):")
    initial_state = take_input()

    print("\nEnter the goal state (e.g., T1 T2 T3):")
    Puzzle.goal_state = take_input()

    Puzzle.needs_hueristic = True

    start_time = time.time()

    puzzle = Puzzle(initial_state)
    result = hill_climbing_search(puzzle)

    end_time = time.time()

    if result:
        final_state, states_explored, optimal_path = result
        if final_state == Puzzle.goal_state:
            print("\nSuccess!")
            print("Start State:")
            for row in initial_state:
                print(row)
            print("Goal State:")
            for row in Puzzle.goal_state:
                print(row)
            print(f"Total number of states explored: {states_explored}")
            print(f"Total number of states to the optimal path: {len(optimal_path)}")
            print("Optimal Path:")
            for state in optimal_path:
                for row in state:
                    print(row)
                print()
            print(f"Optimal Path Cost: {len(optimal_path) - 1}")
            print(f"Time taken for execution: {end_time - start_time:.4f} seconds")
        else:
            print("\nFailure!")
            print("Start State:")
            for row in initial_state:
                print(row)
            print("Goal State:")
            for row in Puzzle.goal_state:
                print(row)
            print(f"Total number of states explored before termination: {states_explored}")
    else:
        print("\nFailure!")
        print("Start State:")
        for row in initial_state:
            print(row)
        print("Goal State:")
        for row in Puzzle.goal_state:
            print(row)
        print("Total number of states explored before termination: 0")